# 限流器详细图解

## 🎯 核心概念对应表

| 现实世界 | 代码中 | 作用 |
|---------|--------|------|
| 🪣 桶 | `tokens chan struct{}` | 存放令牌的容器 |
| 🎫 入场券 | `struct{}{}` | 令牌（空结构体，不占内存） |
| 👷 工作人员 | `goroutine` | 后台定时发放令牌 |
| ⏰ 发券间隔 | `time.Ticker` | 每隔固定时间发一张券 |
| 👤 顾客拿券 | `<-tokens` | 从 channel 取令牌 |

---

## 📝 代码结构拆解

### 第 1 部分：创建桶

```go
tokens: make(chan struct{}, burstSize)
```

**问题引导**：
- 这是一个什么类型的 channel？
  → buffered channel（带缓冲的）
- 为什么是 `struct{}`？
  → 空结构体不占内存，我们只关心"有没有"，不关心"是什么"
- burstSize 是什么？
  → 桶的容量，比如设为 3，就能装 3 张券

**理解检查**：
如果 burstSize = 3，这个 channel 最多能存几个 `struct{}{}`？
答：3 个

---

### 第 2 部分：初始化 - 填满桶

```go
for i := 0; i < burstSize; i++ {
    limiter.tokens <- struct{}{}
}
```

**问题引导**：
- 为什么要先填满桶？
  → 程序刚启动时，如果桶是空的，第一批请求都会被拒绝
  → 先填满桶，允许程序启动时有一些"突发"请求

**类比**：
游乐场开门前，先准备好几张入场券，让前几个顾客不用等

---

### 第 3 部分：后台工作人员 - 定时发放令牌

**这是你要实现的部分！**

**流程图**：
```
                    ┌─────────────────┐
                    │  time.Ticker    │
                    │  (定时器)       │
                    └────────┬────────┘
                             │
                             │ 每隔 rate 时间
                             ↓
                    ┌─────────────────┐
                    │   for range     │
                    │   ticker.C      │
                    └────────┬────────┘
                             │
                             ↓
              ┌──────────────────────────┐
              │      select {            │
              │      case tokens <-..    │  桶未满 → 放入令牌 ✅
              │      default:            │  桶满了 → 丢弃 ❌
              │      }                   │
              └──────────────────────────┘
```

**关键问题**：

**Q1**: 为什么需要 select + default？
**A**: 如果桶满了（已经有 3 张券），再往里放会阻塞
     用 default 可以"试试看"，放不进去就算了

**Q2**: 为什么在 goroutine 里？
**A**: 这是后台任务，不能阻塞主程序

**Q3**: `for range ticker.C` 是什么意思？
**A**: ticker.C 是一个 channel
     每隔固定时间，这个 channel 会收到一个信号
     for range 就是"每次收到信号，就执行一次"

---

### 第 4 部分：Allow() - 非阻塞获取令牌

**你要实现的第二个方法**

**场景**：顾客来了，想立即知道能不能进

```
顾客："我能进吗？"

情况 1: 桶里有券
  → 拿走 1 张，返回 true

情况 2: 桶里没券
  → 立即返回 false（不等待）
```

**代码思路**：
```
用 select 同时监听两个情况：
  case 1: 能从 tokens 取到令牌 → return true
  case 2: default（取不到）→ return false
```

**关键**：这是**非阻塞**的，不会等待

---

### 第 5 部分：Wait() - 阻塞获取令牌

**你要实现的第三个方法**

**场景**：顾客来了，没券也愿意等

```
顾客："我可以等，一定要进去"

→ 阻塞，直到桶里有券
→ 拿到券后才返回
```

**代码思路**：
```
直接从 tokens 读取（会阻塞）
<-rl.tokens
```

**关键**：这是**阻塞**的，会一直等

---

## 🔢 参数理解

### requestsPerSecond（每秒请求数）

```go
requestsPerSecond = 5
→ 每秒允许 5 个请求
→ rate = 1 秒 / 5 = 200ms
→ 每 200ms 发放 1 个令牌
```

### burstSize（突发容量）

```go
burstSize = 3
→ 桶的容量是 3
→ 允许"攒"最多 3 个令牌
→ 允许短时间内有 3 个"突发"请求
```

**例子**：
```
场景 1: 突发请求
- 系统空闲了 1 秒，桶攒了 3 个令牌
- 突然来了 3 个请求
- 都能立即通过（因为桶里有 3 个令牌）

场景 2: 持续请求
- 持续有请求来
- 桶始终空着
- 每 200ms 才能通过 1 个请求（平滑限速）
```

---

## 🎮 实战场景演练

### 场景 A：微信 API 限流

```
微信规定：每秒最多 10 次请求

你的设置：
limiter := NewRateLimiter(10, 5)
  → 平均每秒 10 次（每 100ms 一个令牌）
  → 突发容量 5（短时间内可以 5 个请求）
```

### 场景 B：数据库连接池

```
数据库最多 20 个连接

你的设置：
limiter := NewRateLimiter(20, 20)
  → 最多 20 个并发连接
  → 超过了就等待
```

---

## ✅ 检查理解

**测试 1**：
```
limiter := NewRateLimiter(5, 3)
```
- rate 是多少？
  → 1 秒 / 5 = 200ms
- 桶容量是多少？
  → 3
- 如果瞬间来 10 个请求，会怎样？
  → 前 3 个立即通过（用桶里的令牌）
  → 剩下 7 个，每 200ms 通过 1 个

**测试 2**：
```
if limiter.Allow() {
    callAPI()
} else {
    fmt.Println("被限流了")
}
```
- Allow() 返回 false 意味着什么？
  → 桶里没令牌了
  → 不会等待，直接拒绝

**测试 3**：
```
limiter.Wait()
callAPI()
```
- Wait() 会干什么？
  → 阻塞，直到桶里有令牌
  → 保证一定能执行

---

## 🤔 思考题（帮助理解）

1. **为什么叫"桶"而不是"队列"？**
   提示：桶有容量上限，满了就溢出

2. **如果不用 channel，用什么实现令牌桶？**
   提示：可以用 int 变量 + Mutex，但 channel 更优雅

3. **如果 burstSize = 1 会怎样？**
   提示：无法突发，严格限速

4. **Allow() 和 Wait() 分别适合什么场景？**
   Allow() → Web 服务器（快速失败，返回 429 Too Many Requests）
   Wait() → 后台任务（可以慢慢执行）

---

## 🎯 实现任务拆解

**任务 1：实现后台发放令牌**
1. 创建 time.Ticker
2. 启动 goroutine
3. 在 goroutine 中循环
4. 每次循环尝试发送令牌（用 select + default）

**任务 2：实现 Allow()**
1. 用 select 尝试从 tokens 读取
2. 能读到 → return true
3. 读不到（default）→ return false

**任务 3：实现 Wait()**
1. 直接从 tokens 读取（阻塞）
2. 读到了就返回

**任务 4：实现 cleanup**
（暂时不用实现，这是停止定时器的）

---

## 💡 提示：从最简单的开始

**建议顺序**：
1. 先实现 Wait()（最简单，只有 1 行代码）
2. 再实现 Allow()（稍复杂，需要 select）
3. 最后实现后台 goroutine（最复杂）

**调试技巧**：
```go
// 在关键位置加打印
go func() {
    for range limiter.ticker.C {
        fmt.Println("尝试发放令牌...")
        select {
        case limiter.tokens <- struct{}{}:
            fmt.Println("✓ 令牌发放成功")
        default:
            fmt.Println("✗ 桶满了，丢弃令牌")
        }
    }
}()
```

---

现在清楚了吗？从哪个部分开始不懂，我可以继续解释！
