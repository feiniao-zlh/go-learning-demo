# 🚀 Go 并发编程 - 实战项目合集

## 📖 为什么需要实战项目？

你可能已经学完了 `goroutine`、`channel`、`select` 的基础语法，但是：
- 😵 **感觉很抽象**：不知道实际工作中怎么用
- 🤔 **想不到场景**：不清楚这些特性解决什么问题
- 💭 **面试被问懵**：面试官问"你用 Go 做过什么项目？"

**这个目录就是为了解决这些问题！**

这里有 **4 个经典的真实场景**，每个都是工作中会遇到的实际问题。通过实现它们，你会真正理解 Go 并发编程的威力！

---

## 🎯 项目列表

### 1️⃣ 并发下载器 (Concurrent Downloader)
**文件**: `01_concurrent_downloader.go`

**真实场景**: 批量下载文件，但要限制同时下载的数量

**涉及技术**:
- ✓ Worker Pool 模式
- ✓ Channel 作为任务队列
- ✓ Goroutine 并发执行

**工作中的应用**:
- 爬虫批量抓取网页
- 批量下载图片/视频
- 并行处理文件

**难度**: ⭐⭐☆☆☆

---

### 2️⃣ API 限流器 (Rate Limiter)
**文件**: `02_rate_limiter.go`

**真实场景**: 调用第三方 API 有频率限制，必须控制调用速度

**涉及技术**:
- ✓ 令牌桶算法
- ✓ time.Ticker 定时器
- ✓ Select 非阻塞操作

**工作中的应用**:
- 微信/支付宝 API 调用
- 数据库连接池管理
- 限制用户请求频率

**难度**: ⭐⭐⭐☆☆

---

### 3️⃣ 超时重试机制 (Timeout & Retry)
**文件**: `03_timeout_retry.go`

**真实场景**: 调用不稳定的服务，需要超时控制和自动重试

**涉及技术**:
- ✓ Select 超时控制
- ✓ 指数退避算法
- ✓ Channel 结果传递

**工作中的应用**:
- 调用第三方服务
- 微服务之间的通信
- 数据库查询重试

**难度**: ⭐⭐⭐⭐☆

---

### 4️⃣ 并发安全缓存 (Thread-Safe Cache)
**文件**: `04_simple_cache.go`

**真实场景**: 频繁查询数据库太慢，需要缓存加速

**涉及技术**:
- ✓ sync.RWMutex 读写锁
- ✓ Map 数据存储
- ✓ 后台 Goroutine 清理

**工作中的应用**:
- Redis/Memcached 的简化版
- 本地缓存加速
- 热点数据缓存

**难度**: ⭐⭐⭐⭐☆

---

## 🏃 如何开始？

### 推荐学习顺序

```
1. 并发下载器 (最简单，建立信心)
   ↓
2. 限流器 (理解实际应用)
   ↓
3. 超时重试 (掌握复杂场景)
   ↓
4. 并发缓存 (综合运用)
```

### 学习方法

每个项目都采用 **"Learn by Doing"** 模式：

1. **阅读场景描述** - 理解要解决什么问题
2. **查看 TODO(human)** - 找到需要你实现的部分
3. **独立实现** - 根据提示完成代码
4. **运行测试** - 看看效果是否正确
5. **思考问题** - 回答文件末尾的思考题

### 运行示例

```bash
# 进入目录
cd real_world_practices

# 运行某个项目
go run 01_concurrent_downloader.go

# 建议加上 race detector 检测并发问题
go run -race 01_concurrent_downloader.go
```

---

## 💡 每个项目的核心亮点

### 项目 1: 并发下载器
**核心问题**: 如何限制并发数量？
**答案**: Worker Pool 模式 - 固定数量的 worker，从队列取任务

**关键代码**:
```go
jobs := make(chan File, len(files))
results := make(chan Result, len(files))

// 启动 3 个 worker
for w := 1; w <= 3; w++ {
    go worker(jobs, results)
}
```

---

### 项目 2: 限流器
**核心问题**: 如何控制速度？
**答案**: 令牌桶 - 定时发放令牌，没有令牌就不能执行

**关键代码**:
```go
tokens := make(chan struct{}, capacity)
ticker := time.NewTicker(rate)

go func() {
    for range ticker.C {
        select {
        case tokens <- struct{}{}:  // 发放令牌
        default:  // 桶满了
        }
    }
}()
```

---

### 项目 3: 超时重试
**核心问题**: 如何避免无限等待？
**答案**: Select + time.After + 指数退避

**关键代码**:
```go
select {
case result := <-resultCh:
    return result  // 成功
case <-time.After(timeout):
    // 重试，增加 backoff
    backoff *= 2
}
```

---

### 项目 4: 并发缓存
**核心问题**: 多个 goroutine 如何安全访问 map？
**答案**: RWMutex - 多读少写的场景

**关键代码**:
```go
// 读操作用读锁
func (c *Cache) Get(key string) {
    c.mu.RLock()
    defer c.mu.RUnlock()
    // ...
}

// 写操作用写锁
func (c *Cache) Set(key string, value interface{}) {
    c.mu.Lock()
    defer c.mu.Unlock()
    // ...
}
```

---

## 🎓 面试中如何展示这些项目？

### 项目 1: 并发下载器
**面试官**: "你用 Go 做过什么项目？"
**你**: "我实现过一个并发下载器，使用 Worker Pool 模式限制并发数量，避免同时打开太多连接。通过 channel 分发任务，实现了高效的并行下载。"

### 项目 2: 限流器
**面试官**: "如何保护服务不被打垮？"
**你**: "我实现过一个基于令牌桶算法的限流器。使用 channel 作为令牌桶，time.Ticker 定时发放令牌，select 的 default 实现非阻塞获取。这个方案既能限制平均速率，又允许合理的突发流量。"

### 项目 3: 超时重试
**面试官**: "调用外部服务超时了怎么办？"
**你**: "我实现过一个带超时重试的机制。使用 select 配合 time.After 实现超时控制，采用指数退避避免对服务造成压力。这在调用不稳定的第三方服务时特别有用。"

### 项目 4: 并发缓存
**面试官**: "如何提升系统性能？"
**你**: "我实现过一个并发安全的缓存系统。使用 RWMutex 保证线程安全，允许多个读操作并发执行。后台 goroutine 定时清理过期数据，避免内存泄漏。在实际项目中，缓存将查询性能提升了 10 倍以上。"

---

## 📊 完成进度

- [ ] 01_concurrent_downloader.go
- [ ] 02_rate_limiter.go
- [ ] 03_timeout_retry.go
- [ ] 04_simple_cache.go

---

## 🚀 进阶方向

完成这 4 个项目后，你可以：

1. **优化性能**
   - 使用 pprof 分析瓶颈
   - 减少内存分配
   - 优化锁的粒度

2. **增强功能**
   - 限流器：添加分布式支持
   - 缓存：实现 LRU 淘汰策略
   - 下载器：添加断点续传

3. **解决更复杂的问题**
   - 实现 Singleflight（防止缓存击穿）
   - 实现熔断器（Circuit Breaker）
   - 实现链路追踪

---

## 💬 常见问题

### Q: 这些项目太简单了？
A: 这些是**教学简化版本**。真实的 Redis、Nginx 的限流器、Hystrix 的熔断器，核心思想就是这些。掌握这些基础后，你能看懂任何复杂系统的实现。

### Q: 工作中真的会用到吗？
A: **100% 会用到**！这些都是后端开发的标配：
- 限流：几乎所有 Web 服务都需要
- 缓存：性能优化必备
- 重试：微服务通信标配
- 并发控制：处理大量请求的基础

### Q: 先做这些还是先学完基础？
A: **现在就可以做**！这些项目就是用来巩固基础的。你已经学了 goroutine、channel、select，正好用这些项目融会贯通。

---

## 🎯 学习建议

1. **不要死记硬背** - 理解每个设计的原因
2. **动手实践** - 自己写一遍才是真的懂
3. **举一反三** - 想想还能用在哪些场景
4. **面试准备** - 每个项目都能成为面试谈资

---

**开始你的第一个实战项目吧！** 💪

从 `01_concurrent_downloader.go` 开始，逐步进阶！
